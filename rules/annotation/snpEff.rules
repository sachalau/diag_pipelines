rule create_snpEff_config_file:
    output:
        config_file = "references/{taxId}/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/snpEff.config",
    shell:
        """
        echo "codon.Bacterial_and_Plant_Plastid : TTT/F, TTC/F, TTA/L, TTG/L+, TCT/S, TCC/S, TCA/S, TCG/S, TAT/Y, TAC/Y, TAA/*, TAG/*, TGT/C, TGC/C, TGA/*, TGG/W, CTT/L, CTC/L, CTA/L, CTG/L+, CCT/P, CCC/P, CCA/P, CCG/P, CAT/H, CAC/H, CAA/Q, CAG/Q, CGT/R, CGC/R, CGA/R, CGG/R, ATT/I+, ATC/I+, ATA/I+, ATG/M+, ACT/T, ACC/T, ACA/T, ACG/T, AAT/N, AAC/N, AAA/K, AAG/K, AGT/S, AGC/S, AGA/R, AGG/R, GTT/V, GTC/V, GTA/V, GTG/V+, GCT/A, GCC/A, GCA/A, GCG/A, GAT/D, GAC/D, GAA/E, GAG/E, GGT/G, GGC/G, GGA/G, GGG/G" > {output[config_file]}
        echo "{wildcards.nucleotide_ncbidb_accession}.genome: H37Rv" >> {output[config_file]}
        echo "{wildcards.nucleotide_ncbidb_accession}.chromosomes: {wildcards.nucleotide_ncbidb_accession}" >> {output[config_file]}
        echo "{wildcards.nucleotide_ncbidb_accession}.{wildcards.nucleotide_ncbidb_accession}.codonTable: Bacterial_and_Plant_Plastid" >> {output[config_file]}
        """


rule link_gff_files_for_snpEff_config:
    input:
        annotation = "references/{taxId}/{nucleotide_ncbidb_accession}/genome_fixed.{annotation_extension}",
        genome = "references/{taxId}/{nucleotide_ncbidb_accession}/genome.fasta",
    output:
        refseq = "references/{taxId}/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/data/{nucleotide_ncbidb_accession}/genes.{annotation_extension}",
        sequences = "references/{taxId}/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/data/{nucleotide_ncbidb_accession}/sequences.fa",
    shell:
        """
        sed "s/\\ttRNA\\t/\\trRNA\\t/" {input[annotation]} > {output[refseq]}
        cp {input[genome]} {output[sequences]}
        """




rule fix_gff_for_snpEff:
    input:
        annotation = "{any_gff}.{annotation_extension}",
    output:
        annotation_fixed = "{any_gff}_fixed.{annotation_extension}",
    run:
        from BCBio import GFF
        import Bio
        from Bio import SeqIO
        if wildcards["annotation_extension"]=="gff":
            gff = GFF.parse(open(input["annotation"]), limit_info={'gff_source_type':[('RefSeq', 'tRNA'), ("RefSeq", "gene"), ("RefSeq", "CDS"), ("RefSeq", "ncRNA"), ("RefSeq", "exon"), ("RefSeq", "rRNA"), ("RefSeq", "pseudogene"), ("RefSeq", "repeat_region"), ("RefSeq", "mobile_genetic_element"), ("RefSeq", "sequence_feature"), ("RefSeq", "transcript"), ("RefSeq", "region")], 'gff_source':['RefSeq']})
            for record in gff:
                for features in record.features:
                    if features.type=="pseudogene":
                        if "gene" not in features.qualifiers:
                            features.qualifiers["gene"]=features.qualifiers["locus_tag"]
            GFF.write([record], open(output["annotation_fixed"], "w"))
        elif wildcards["annotation_extension"]=="gbk":
            gbk = SeqIO.parse(open(input["annotation"]), "genbank")
            for record in gbk:
                record.name = record.annotations["accessions"][0] + "." + str(record.annotations["sequence_version"])
#                for features in record.features:
#                    if features.type=="rRNA":
#                        features.qualifiers["gene_biotype"]="rRNA"
#                        features.qualifiers["gene_type"]="rRNA"
#                        features.qualifiers["biotype"]="rRNA"
#                    if features.type=="gene" and features.qualifiers["locus_tag"]==["Rvnr02"]:
#                        features.qualifiers["gene_biotype"]="rRNA"
#                        features.qualifiers["gene_type"]="rRNA"
#                        features.qualifiers["biotype"]="rRNA"
            SeqIO.write(record, open(output["annotation_fixed"], "w"), "genbank")
        

rule load_annotation_into_BioSQL:
    input:
        gff = "{any_gff}.{annotation_extension}",
    output:
        loaded = "{any_gff}.{annotation_extension}.txt"
    run:
        from Bio import SeqIO
        from BCBio import GFF
        from BioSQL import BioSeqDatabase
        server = BioSeqDatabase.open_database(driver="psycopg2", user="sacha", host = "localhost", db="biosqldb")
        db = server["orchids"]
        if wildcards["annotation_extension"]=="gff":
            count = db.load(GFF.parse(open(input["gff"])))
        elif wildcards["annotation_extension"]=="gbff":
            count = db.load(SeqIO.parse(open(input["gbff"]), "genbank"))
        print("Loaded %i records" % count)
        server.commit() 

        
        
rule create_snpEff_database:
    conda:
        pipeline_path + "envs/snpEff.yml"
    input:
        annotation = "references/{taxId}/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/data/{nucleotide_ncbidb_accession}/genes.{annotation_extension}",
        sequences = "references/{taxId}/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/data/{nucleotide_ncbidb_accession}/sequences.fa",
        config_file = "references/{taxId}/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/snpEff.config",
    output:
        predictor_bin = "references/{taxId}/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/data/{nucleotide_ncbidb_accession}/snpEffectPredictor.bin",
    shell:
        """
        if [[ "{wildcards.annotation_extension}" = "gff" ]]
        then
            build="gff3"
        else
            build="genbank"
        fi
        snpEff build -${{build}} -nodownload -v -config {input[config_file]} {wildcards.nucleotide_ncbidb_accession}
        """


        

rule annotate_vcf_with_snpEff:
    conda:
        pipeline_path + "envs/snpEff.yml"
    input:
        vcf = "samples/{sample}/genotyping/{any_genotyper}/{nucleotide_ncbidb_accession}/{any_mapper}/{any_vcf}.vcf",
        predictor_bin = lambda wildcards: "references/" + accession_to_taxId[wildcards["nucleotide_ncbidb_accession"]] + "/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/data/{nucleotide_ncbidb_accession}/snpEffectPredictor.bin",
        config_file = lambda wildcards: "references/" + accession_to_taxId[wildcards["nucleotide_ncbidb_accession"]] + "/{nucleotide_ncbidb_accession}/{annotation_extension}/snpEff/snpEff.config",
    output:
        annotated_vcf = temp("samples/{sample,[^/]+}/genotyping/{any_genotyper,[^/]+}/{nucleotide_ncbidb_accession}/{any_mapper,[^/]+}/{any_vcf}_snpEff_{annotation_extension}.vcf")
    shell:
        """
        snpEff ann -upDownStreamLen 2000 -noStats -config {input[config_file]} -nodownload -ss 0 -spliceRegionExonSize 0 -spliceRegionIntronMax 0 -spliceRegionIntronMin 0 {wildcards.nucleotide_ncbidb_accession} {input[vcf]} > {output[annotated_vcf]}
        """

        
rule split_vcf:
    conda:
        pipeline_path + "envs/bcftools.yml",
    input:
        vcf = "{any_vcf}.vcf",
    output:
        vcf_split = temp("{any_vcf}_split.vcf"),
    shell:
        """
        bcftools norm --multiallelics - {input[vcf]} > {output[vcf_split]}
        """


        
rule format_vcf_before_loading_into_variant_table:
    conda:
        pipeline_path + "envs/bcftools.yml",
    input:
        vcf = "{any_vcf}.vcf.gz",
    output:
        vcf_formated = temp("{any_vcf}_formated_variant.tsv"),
    shell:
        """
        bcftools query -f "%CHROM\\t%POS\\t%REF\\t%ALT\\n" {input[vcf]} | awk '$4!="<NON_REF>"' > {output[vcf_formated]}
        """

        
rule format_vcf_before_loading_into_genotype_table:
    conda:
        pipeline_path + "envs/bcftools.yml",
    input:
        vcf = "{any_vcf}.vcf.gz",
    output:
        vcf_formated = temp("{any_vcf}_formated_genotype.tsv"),
    shell:
        """
        bcftools query -f "[%SAMPLE]\\t%CHROM\\t%POS\\t%REF\\t%ALT\\t%QUAL\\t[%AD]\\t[%DP]\\t%FILTER\\n" {input[vcf]} > {output[vcf_formated]}
        """

        
rule extract_ANN_from_snpEff:
    conda:
        pipeline_path + "envs/bcftools.yml"
    input:
        vcf = "{any_vcf}_snpEff.vcf.gz",
    output:
        ann = temp("{any_vcf}_snpEff_ANN.tsv"),
    shell:
        """
        bcftools query -f "%CHROM %POS %REF %ALT %ANN\\n" {input[vcf]} > {output[ann]}
        """


rule format_snpEff_annotation_for_db:
    input:
        vcf = "{any_vcf}_snpEff_ANN.tsv",
    output:
        formated = "{any_vcf}_snpEff_db.tsv",
    run:
        import pandas
        snpEff = pandas.read_csv(input["vcf"], sep=" ", names=["Chrom", "Pos", "Ref", "Alt","Annotation"], index_col=[0,1,2,3])["Annotation"].str.split(",", expand=True).stack().reset_index()[["Chrom", "Pos", "Ref", "Alt", 0]].set_index(["Chrom", "Pos", "Ref", "Alt"])[0].str.split("|", expand=True)
        snpEff.columns = ["Allele", "Annotation", "Putative_impact", "Gene_Name", "Gene_ID", "Feature_Type", "Feature_ID", "Transcript_biotype", "Rank", "HGVS.c", "HGVS.p", "cDNA_len", "CDS_len", "Protein_len", "Dist_to_feat", "Errors"]
        snpEff.pop("Rank")
        snpEff.to_csv(output["formated"], sep="\t", header=True, index=True, chunksize=500000)


rule extract_annotation_for_protein_change:
    input:
        formated = "{any_vcf}_snpEff_db.tsv",
    output:
        substitution = temp("{any_vcf}_snpEff_formated.tsv"),        
    run:
        import pandas, re, hgvs.parser, hgvs.validator
        def n_parse_error(x):
            try:
                return parser.parse_c_posedit(x)
            except TypeError:
                return ""
            except hgvs.exceptions.HGVSParseError as e:
                reg = r'n\.'
                if re.match(reg, x):
                    try:
                        return(parser.parse_n_posedit(x.replace("n.", "")))
                    except hgvs.exceptions.HGVSParseError as e:
                        print(x)
                        print(e)
                else:
                    print(e)
        def cn_parse_errors(x):
            try:
                return parser.parse_c_posedit(x.replace("c.",""))
            except hgvs.exceptions.HGVSParseError as e:
                try:
                    return parser.parse_c_posedit(x.replace("n.",""))
                except hgvs.exceptions.HGVSParseError as e1:
                    print(e1)
            except AttributeError:
                return ""

        def p_parse_errors(x):
            try:
                return parser.parse_p_posedit(x)
            except hgvs.exceptions.HGVSParseError as e:
                reg = r'^(?:[A-z][a-z]{2}){2,}\d+(?:[A-Z][a-z]{2}){2,}$'
                if re.match(reg, x):
                    start_AA = x[:3]
                    end_AA = re.split(r'\d+', x)[0][-3:]
                    start_pos = re.search(r'\d+', x).group(0)
                    end_pos = str(int(start_pos)-1+int(len(re.split(r'\d+', x)[0])/3))
                    alt_AA = re.split(r'\d+', x)[1]
                    p_pos = parser.parse_p_posedit(start_AA+start_pos+"_"+end_AA+end_pos+"delins"+alt_AA)
                    return(p_pos)
                else:
                    print(e)
            except TypeError:
                return [""]*3
            if type(p_pos.edit) is hgvs.edit.AASub:
                return(pandas.Series([p_pos.pos.start.base, p_pos.pos.start.aa, p_pos.edit.alt]))
            else:
                return(pandas.Series([""]*3))                   
        snpEff = pandas.read_csv(input["formated"], sep="\t", header=0)
        parser = hgvs.parser.Parser()
        snpEff = snpEff[~snpEff["Annotation"].isin(["intergenic_region", "downstream_gene_variant", "non_coding_transcript_variant", "intragenic_variant"])]
        final_annotation = []
        for index, row in snpEff.iterrows():
            gene_id = row["Feature_ID"].replace("TRANSCRIPT_", "").replace("gene-", "").replace("rna-", "")
            if row["Annotation"] == "non_coding_transcript_exon_variant":
                tmp = n_parse_error(row["HGVS.c"])
                pos = tmp.pos.start.base
                posend = ""
                if tmp.pos.start != tmp.pos.end:
                    posend = tmp.pos.end.base
                try:
                    alt = tmp.edit.alt
                except AttributeError:
                    alt = ""
                t = tmp.edit.type
                final_annotation.append([gene_id, row["Annotation"], pos, row["HGVS.c"]])
            elif row["Annotation"] == "synonymous_variant" and len(row["Ref"])>1:
                pass
            elif row["Annotation"] != "upstream_gene_variant":
                tmp = p_parse_errors(row["HGVS.p"].replace("p.", ""))
                if str(tmp.edit.type) == "delins" and row["Annotation"]=="missense_variant":
                    final_annotation.append([gene_id, row["Annotation"], row["Dist_to_feat"], str(tmp)])
                else:
                    final_annotation.append([gene_id, row["Annotation"], row["Dist_to_feat"], row["HGVS.p"]])
            elif row["Annotation"] == "upstream_gene_variant":
                if row["Transcript_biotype"]!="pseudogene":
                    final_annotation.append(list(row[["Chrom", "Pos", "Ref", "Alt"]]) + [gene_id, row["Annotation"], -row["Dist_to_feat"], row["HGVS.c"]])
        pandas.DataFrame(final_annotation).to_csv(output["substitution"], index=False, sep="\t")


        
                                  
